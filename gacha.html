<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <base target="_top">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <script src="gacha-logic.js"></script>
    
    <!-- Google Fonts: Noto Sans JP -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">

    <style>
      body {
        font-family: "Noto Sans JP", "Noto Sans CJK JP", "IPAGothic", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
      }
      /* Gacha Animation CSS */
      .animate-shake { animation: shake 0.1s infinite; }
      @keyframes shake {
        0% { transform: rotate(0deg); }
        25% { transform: rotate(2deg); }
        50% { transform: rotate(0deg); }
        75% { transform: rotate(-2deg); }
        100% { transform: rotate(0deg); }
      }

      .animate-spin-knob {
        transform-origin: 200px 380px; /* Center of knob */
        animation: spin-knob 1s ease-in-out;
      }
      @keyframes spin-knob {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Active Capsule Animation (Phase 2: Roll & Scale) */
      .active-capsule {
        opacity: 0;
        transform-origin: center center;
        transition: all 2s cubic-bezier(0.25, 1, 0.5, 1); /* Ease-out like */
        z-index: 50;
        pointer-events: auto; /* Clickable */
        cursor: pointer;
      }
      .capsule-appear {
        opacity: 1;
        /* Target: Center of machine (200, 325 approx) + Scale 1.5 + Rotate */
        /* Note: Translate relies on initial position logic in JS */
        /* JS will set specific translate end state via style or class if fixed */
      }
      
      /* Simple CSS for crack overlay */
      .crack-effect::after {
        content: '';
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background: radial-gradient(circle, transparent 40%, rgba(255,255,255,0.8) 42%, transparent 45%),
                    linear-gradient(45deg, transparent 48%, white 50%, transparent 52%);
        opacity: 0.8;
        pointer-events: none;
        animation: crack-flash 0.5s infinite alternate;
      }
      @keyframes crack-flash {
        0% { opacity: 0.5; }
        100% { opacity: 1; }
      }

      .promotion-bg {
        background-color: #330033 !important; /* Dark purple */
        background-image: radial-gradient(#FFD700 1px, transparent 1px);
        background-size: 20px 20px;
        transition: background 1s;
      }

      /* Testability Hook */
      body[data-gacha-status] { }
    </style>
  </head>
  <body class="bg-yellow-50 min-h-screen flex flex-col items-center justify-center p-4 transition-colors duration-1000">

    <!-- Definitions for SVG Gradients (Rainbow) -->
    <svg width="0" height="0" class="absolute">
      <defs>
        <linearGradient id="rainbowGradient" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" style="stop-color:#ff0000;stop-opacity:1" />
          <stop offset="16%" style="stop-color:#ff7f00;stop-opacity:1" />
          <stop offset="33%" style="stop-color:#ffff00;stop-opacity:1" />
          <stop offset="50%" style="stop-color:#00ff00;stop-opacity:1" />
          <stop offset="66%" style="stop-color:#0000ff;stop-opacity:1" />
          <stop offset="83%" style="stop-color:#4b0082;stop-opacity:1" />
          <stop offset="100%" style="stop-color:#9400d3;stop-opacity:1" />
        </linearGradient>
      </defs>
    </svg>

    <div id="app" class="max-w-md w-full bg-white rounded-xl shadow-lg overflow-hidden p-6 text-center relative">
      <h1 class="text-2xl font-bold text-gray-800 mb-6">お楽しみガチャ</h1>

      <!-- ガチャマシーンエリア -->
      <div class="relative w-full max-w-[300px] mx-auto mb-8 aspect-[400/650]">
        <!-- Machine Container (Inline SVG) -->
        <div id="machine-container" class="w-full h-full drop-shadow-xl relative">
<svg width="100%" height="100%" viewBox="0 0 400 650" xmlns="http://www.w3.org/2000/svg" id="machine">
  <defs>
    <linearGradient id="m-body-grad" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#FFD54F;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#FFB300;stop-opacity:1" />
    </linearGradient>
    <linearGradient id="m-panel-grad" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#FFF8E1;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#FFECB3;stop-opacity:1" />
    </linearGradient>
    <radialGradient id="m-dome-grad" cx="50%" cy="50%" r="50%" fx="30%" fy="30%">
      <stop offset="0%" style="stop-color:#FFFFFF;stop-opacity:0.4" />
      <stop offset="80%" style="stop-color:#E0F7FA;stop-opacity:0.2" />
      <stop offset="100%" style="stop-color:#B2EBF2;stop-opacity:0.6" />
    </radialGradient>
    <linearGradient id="m-dome-reflection" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#FFFFFF;stop-opacity:0.8" />
      <stop offset="50%" style="stop-color:#FFFFFF;stop-opacity:0" />
    </linearGradient>
    <radialGradient id="m-knob-grad" cx="50%" cy="50%" r="50%" fx="40%" fy="40%">
      <stop offset="0%" style="stop-color:#FFFFFF;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#FF4081;stop-opacity:1" />
    </radialGradient>
    <radialGradient id="m-energy-glow" cx="50%" cy="50%" r="50%">
      <stop offset="0%" style="stop-color:#FFD700;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#FFD700;stop-opacity:0" />
    </radialGradient>

    <filter id="m-drop-shadow" x="-20%" y="-20%" width="140%" height="140%">
      <feGaussianBlur in="SourceAlpha" stdDeviation="5" result="blur" />
      <feOffset in="blur" dx="0" dy="5" result="offsetBlur" />
      <feFlood flood-color="rgba(0,0,0,0.3)" result="colorBlur" />
      <feComposite in="colorBlur" in2="offsetBlur" operator="in" result="shadow" />
      <feMerge>
        <feMergeNode in="shadow" />
        <feMergeNode in="SourceGraphic" />
      </feMerge>
    </filter>

    <path id="m-capsule-bottom" d="M -45 0 A 45 45 0 0 0 45 0 L -45 0 Z" />
    <path id="m-capsule-top" d="M -45 0 A 45 45 0 0 1 45 0 L -45 0 Z" fill="#FFFFFF" opacity="0.5" />
    <g id="m-capsule" filter="url(#m-drop-shadow)">
      <use href="#m-capsule-bottom" class="capsule-color"/>
      <use href="#m-capsule-top" />
      <ellipse cx="-15" cy="-15" rx="20" ry="10" rotate="-30" fill="white" opacity="0.7"/>
    </g>
  </defs>

  <g opacity="0.5">
    <circle id="lamp-0" cx="50" cy="100" r="10" fill="#FFD700"><animate attributeName="opacity" values="0.5;1;0.5" dur="3s" repeatCount="indefinite"/></circle>
    <circle id="lamp-1" cx="350" cy="150" r="15" fill="#FF4081"><animate attributeName="opacity" values="0.5;1;0.5" dur="4s" repeatCount="indefinite" begin="1s"/></circle>
    <path d="M 20 550 L 30 530 L 40 550 L 50 530 L 60 550" stroke="#448AFF" stroke-width="3" fill="none"/>
    <path d="M 340 520 L 350 500 L 360 520 L 370 500 L 380 520" stroke="#66BB6A" stroke-width="3" fill="none"/>
  </g>

  <g id="machine-body" filter="url(#m-drop-shadow)" transform="translate(0, 20)">
    <rect x="40" y="240" width="320" height="320" rx="30" fill="url(#m-body-grad)" stroke="#FF8F00" stroke-width="4" />
    <rect x="30" y="280" width="20" height="240" rx="5" fill="#FFB300" stroke="#FF8F00" stroke-width="2"/>
    <rect x="350" y="280" width="20" height="240" rx="5" fill="#FFB300" stroke="#FF8F00" stroke-width="2"/>
    <circle cx="40" cy="300" r="5" fill="#FFECB3"/><circle cx="40" cy="500" r="5" fill="#FFECB3"/>
    <circle cx="360" cy="300" r="5" fill="#FFECB3"/><circle cx="360" cy="500" r="5" fill="#FFECB3"/>
    <rect x="70" y="280" width="260" height="240" rx="15" fill="url(#m-panel-grad)" stroke="#FFE082" stroke-width="2" />
    <rect x="50" y="250" width="300" height="10" rx="5" fill="#FFECB3" stroke="#FFD54F">
        <animate attributeName="fill" values="#FFECB3;#FFF9C4;#FFECB3" dur="2s" repeatCount="indefinite"/>
    </rect>
  </g>

  <g transform="translate(0, 20)">
    <path d="M 50 250 A 150 150 0 0 1 350 250" fill="none" stroke="#FFB300" stroke-width="10" stroke-linecap="round"/>
    <path d="M 55 250 A 145 145 0 0 1 345 250 L 345 250 L 55 250 Z" fill="url(#m-dome-grad)" stroke="#E0F7FA" stroke-width="2"/>
    <g clip-path="url(#m-dome-clip)">
      <clipPath id="m-dome-clip"><path d="M 55 250 A 145 145 0 0 1 345 250 Z" /></clipPath>
      <g transform="translate(120, 200) rotate(-20)"><use href="#m-capsule" fill="#FF5252" /></g>
      <g transform="translate(260, 180) rotate(30)"><use href="#m-capsule" fill="#448AFF" /></g>
      <g transform="translate(190, 130) rotate(10)"><use href="#m-capsule" fill="#FFEB3B" /></g>
      <g transform="translate(150, 260) rotate(-45)"><use href="#m-capsule" fill="#66BB6A" /></g>
      <g transform="translate(100, 150) rotate(20)"><use href="#m-capsule" fill="#AB47BC" /></g>
      <g transform="translate(280, 240) rotate(-15)"><use href="#m-capsule" fill="#FF9800" /></g>
    </g>
    <path d="M 80 180 A 100 100 0 0 1 200 120" fill="none" stroke="url(#m-dome-reflection)" stroke-width="15" opacity="0.7" stroke-linecap="round"/>
  </g>

  <g transform="translate(0, 20)">
    <circle cx="200" cy="380" r="60" fill="#FFD54F" stroke="#FF8F00" stroke-width="3" filter="url(#m-drop-shadow)"/>
    <circle cx="200" cy="380" r="50" fill="#FFF8E1"/>

    <g id="knob" filter="url(#m-drop-shadow)">
      <circle cx="200" cy="380" r="40" fill="url(#m-knob-grad)" stroke="#E91E63" stroke-width="2"/>
      <path d="M 200 340 L 210 370 L 240 380 L 210 390 L 200 420 L 190 390 L 160 380 L 190 370 Z" fill="white" opacity="0.3"/>
      <rect x="180" y="360" width="40" height="40" rx="5" fill="#C2185B" opacity="0.5"/>
    </g>

    <path id="exit-hole" d="M 110 480 Q 200 530 290 480 L 290 540 Q 200 580 110 540 Z" fill="#3E2723" stroke="#5D4037" stroke-width="3" filter="url(#m-drop-shadow)"/>
    <rect x="120" y="470" width="160" height="10" rx="5" fill="#5D4037"/>
    <ellipse id="energy-glow" cx="200" cy="510" rx="80" ry="20" fill="url(#m-energy-glow)" opacity="0.6">
        <animate attributeName="opacity" values="0.6;0.8;0.6" dur="1.5s" repeatCount="indefinite"/>
    </ellipse>
  </g>
</svg>
        </div>

        <!-- Active Capsule Container (No longer fetches external SVG) -->
        <div id="capsule-layer" class="absolute inset-0 pointer-events-none overflow-visible"></div>
      </div>

      <button id="btn-pull" onclick="pullGacha()" disabled class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 rounded-full shadow-lg transition transform active:scale-95 disabled:opacity-50">
        ガチャを回す！
      </button>

      <div id="result-area" class="hidden mt-6 border-t pt-6">
        <div id="loading" class="hidden text-gray-500">...</div>
        
        <div id="result-content" class="hidden">
          <h2 id="item-name" class="text-xl font-bold text-purple-600 mb-2"></h2>
          <img id="item-img" class="w-full h-48 object-contain mb-4 rounded-md bg-gray-100" />
          <div id="item-desc" class="text-left text-gray-700 text-sm bg-gray-50 p-3 rounded markdown-body"></div>
        </div>
      </div>

      <!-- Footer/Credits removed for brevity but ideally kept -->
    </div>

    <script>
      let gachaItems = [];
      let gachaConfig = {};
      const GACHA_FOLDER = 'gacha1';

      const COLOR_MAP = {
          "blue": "#448AFF",
          "red": "#FF5252",
          "silver": "#C0C0C0",
          "gold": "#FFD700",
          "rainbow": "url(#rainbowGradient)",
          "green": "#66BB6A",
          "purple": "#AB47BC"
      };

      const isGasEnvironment = (typeof google !== 'undefined' && google.script && google.script.run);
      const backend = isGasEnvironment ? google.script.run : {
        withSuccessHandler: function(success) { const r = Object.create(this); r._success = success; return r; },
        withFailureHandler: function(failure) { const r = Object.create(this); r._failure = failure; return r; },
        getGachaData: function(folder) {
            fetch(`/api/getGachaData?folder=${encodeURIComponent(folder)}`).then(r=>r.json()).then(d=>this._success&&this._success(d)).catch(e=>this._failure&&this._failure(e));
        },
        getItemAsset: function(folder, img, desc) {
            fetch(`/api/getItemAsset?folder=${encodeURIComponent(folder)}&image=${encodeURIComponent(img)}&description=${encodeURIComponent(desc)}`).then(r=>r.json()).then(d=>this._success&&this._success(d)).catch(e=>this._failure&&this._failure(e));
        }
      };

      // Sound Manager
      const SoundManager = {
        sounds: {},
        init: function() {
            if (typeof Howl === 'undefined') {
                console.warn("Howler.js not loaded.");
                return;
            }
            // Define sound assets.
            // Ideally these paths should be configurable or come from gacha.yaml,
            // but for now we hardcode standard keys mapping to gacha_data/sounds/
            const soundKeys = ['shake', 'capsule_appear', 'crack', 'promotion', 'result'];

            soundKeys.forEach(key => {
                this.sounds[key] = new Howl({
                    src: [`gacha_data/sounds/${key}.mp3`],
                    volume: 0.5,
                    onloaderror: (id, err) => { console.warn(`Sound load error for ${key}:`, err); }
                });
            });
        },
        play: function(key) {
            if (this.sounds[key]) {
                this.sounds[key].play();
            }
        }
      };

      function setGachaState(status) {
          document.body.dataset.gachaStatus = status;
          console.log(`[Gacha State] ${status}`);
      }

      window.onload = () => {
        SoundManager.init();
        setGachaState('loading');
        backend.withSuccessHandler(onDataLoaded).withFailureHandler(onError).getGachaData(GACHA_FOLDER);
      };

      function onDataLoaded(res) {
        if (res.success) {
          gachaConfig = jsyaml.load(res.gachaYaml);
          gachaItems = jsyaml.load(res.itemsYaml);
          if (gachaConfig.name) document.querySelector('h1').innerText = gachaConfig.name;
          document.getElementById('btn-pull').disabled = false;
          setGachaState('idle');
        } else {
          alert(`Error: ${res.error}`);
          setGachaState('error');
        }
      }

      function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

      async function pullGacha() {
        if (gachaItems.length === 0) return;
        const btn = document.getElementById('btn-pull');
        btn.disabled = true;
        document.getElementById('result-area').classList.add('hidden');
        document.getElementById('result-content').classList.add('hidden');
        setGachaState('processing');

        try {
            // 1. Logic: Determine Item and Promotion Chain
            // We need to know final state to prep animations, but logic runs step-by-step.
            // Let's decide item first.
            const initialItem = GachaLogic.drawItemByWeight(gachaItems);
            let currentGradeKey = initialItem.grade;

            // Check Promotion Chain
            // We'll simulate the chain now or just do one step if that's the requirement?
            // The requirement says "If promotion flag true -> interrupt performance".
            // Let's assume we check promotion ONCE for simplicity or loop until final.
            // Requirement Phase 3: "Click -> (If Prom) Effect -> Open".
            // This implies the item INSIDE changes.

            // Let's execute the visual sequence.

            // Phase 1: Action
            setGachaState('shaking');
            SoundManager.play('shake');
            await playActionAnimation();

            // Phase 2: Emission
            setGachaState('capsule_appearing');
            SoundManager.play('capsule_appear');
            const activeCapsule = await spawnCapsule(gachaConfig.grades[currentGradeKey].color);

            // Phase 3: Wait for Open
            setGachaState('waiting_for_open');
            await waitForClick(activeCapsule); // Wait for user to click the capsule

            // Chain Promotion Loop
            while (true) {
                let gradeConfig = gachaConfig.grades[currentGradeKey];
                const nextGradeKey = GachaLogic.checkPromotion(gradeConfig);

                if (nextGradeKey) {
                    // Real Promotion
                    setGachaState('promoting');
                    SoundManager.play('promotion');
                    await playPromotionEffect(activeCapsule, gachaConfig.grades[nextGradeKey].color);
                    currentGradeKey = nextGradeKey;
                    // Loop continues to check next promotion
                } else if (GachaLogic.checkFakePromotion(gradeConfig)) {
                    // Fake Promotion (End of chain)
                    setGachaState('promoting');
                    SoundManager.play('promotion'); // Use same sound or specific fake sound
                    console.log("Fake Promotion Triggered!");
                    await playPromotionEffect(activeCapsule, gradeConfig.color); // Color doesn't change, just effect
                    break;
                } else {
                    // No promotion
                    break;
                }
            }

            // Final Open
            await openCapsule(activeCapsule);

            // Re-draw item if grade changed
            let finalItem = initialItem;
            if (currentGradeKey !== initialItem.grade) {
                const validItems = gachaItems.filter(i => i.grade === currentGradeKey);
                if (validItems.length > 0) finalItem = GachaLogic.drawItemByWeight(validItems);
            }

            // Show Result
            const assets = await fetchItemAsset(finalItem);
            showResult(finalItem, assets);

        } catch (e) {
            onError(e);
        }
      }

      async function playActionAnimation() {
          const knob = document.getElementById('knob');
          const machineBody = document.getElementById('machine-body');
          const energyGlow = document.getElementById('energy-glow');

          // Knob Spin
          knob.classList.add('animate-spin-knob');

          // Machine Shake
          machineBody.classList.add('animate-shake');

          // Energy Glow (Opacity up)
          if(energyGlow) {
              energyGlow.querySelector('animate').setAttribute('values', '0.6;1;0.6'); // Intense
              energyGlow.querySelector('animate').setAttribute('dur', '0.2s');
          }

          await wait(1000); // 1s spin

          knob.classList.remove('animate-spin-knob');
          machineBody.classList.remove('animate-shake');

          // Reset Glow
          if(energyGlow) {
              energyGlow.querySelector('animate').setAttribute('values', '0.6;0.8;0.6');
              energyGlow.querySelector('animate').setAttribute('dur', '1.5s');
          }
      }

      async function spawnCapsule(colorName) {
          const layer = document.getElementById('capsule-layer');
          const exitHole = document.getElementById('exit-hole');

          // Get exit coordinates relative to SVG
          // Since SVG is responsive, we need getBoundingClientRect logic or work in SVG units.
          // SVG units are 400x650.
          // Exit hole 'd' starts around 110, 480.
          // Let's inject an SVG element into layer.

          const capsule = document.createElement('div');
          capsule.classList.add('active-capsule', 'w-24', 'h-24', 'absolute');

          // Initial Pos: Center of Exit Hole (approx 200, 500 in SVG coords)
          // We need to map SVG coords to pixel coords if possible, or use % if viewBox matches aspect.
          // 200/400 = 50% Left. 500/650 = ~77% Top.
          capsule.style.left = '50%';
          capsule.style.top = '77%';
          capsule.style.transform = 'translate(-50%, -50%) scale(0.1) rotate(0deg)';

          // SVG Content
          const colorHex = COLOR_MAP[colorName] || colorName;
          capsule.innerHTML = `
            <svg viewBox="-50 -50 100 100" width="100%" height="100%">
               <use href="#m-capsule" fill="${colorHex}" />
            </svg>
          `;

          layer.appendChild(capsule);

          // Force Reflow
          void capsule.offsetWidth;

          // Animate to Center (50%, 50%)
          requestAnimationFrame(() => {
              capsule.style.top = '50%';
              capsule.style.transform = 'translate(-50%, -50%) scale(1.5) rotate(720deg)';
              capsule.style.opacity = '1';
          });

          // Wait for transition
          await wait(2000);
          return capsule;
      }

      function waitForClick(element) {
          return new Promise(resolve => {
              element.onclick = () => {
                  element.onclick = null; // Once
                  resolve();
              };
          });
      }

      async function playPromotionEffect(capsule, newColorName) {
          // Shake
          capsule.classList.add('animate-shake');
          await wait(500);
          capsule.classList.remove('animate-shake');

          // Crack & Light
          SoundManager.play('crack');
          capsule.classList.add('crack-effect');
          document.body.classList.add('promotion-bg'); // Background Change
          await wait(1000);

          // Change Color
          const colorHex = COLOR_MAP[newColorName] || newColorName;
          capsule.querySelector('use').setAttribute('fill', colorHex);

          await wait(1000);
          capsule.classList.remove('crack-effect');
      }

      async function openCapsule(capsule) {
          // "Pop" open animation (Scale up and fade out or split?)
          // User said "Pop open and show item".
          // We'll scale up and fade out the capsule to reveal item in result box.
          capsule.style.transform = 'translate(-50%, -50%) scale(2) rotate(720deg)';
          capsule.style.opacity = '0';
          await wait(500);
          capsule.remove();
          document.body.classList.remove('promotion-bg');
      }

      function fetchItemAsset(item) {
          return new Promise((resolve, reject) => {
             backend
              .withSuccessHandler((assets) => resolve(assets))
              .withFailureHandler((err) => reject(err))
              .getItemAsset(GACHA_FOLDER, item.image, item.description);
          });
      }

      function showResult(item, assets) {
        if (assets.success) {
          SoundManager.play('result');
          const content = document.getElementById('result-content');
          content.classList.remove('hidden');
          document.getElementById('result-area').classList.remove('hidden');

          document.getElementById('item-name').innerText = item.name;
          document.getElementById('item-img').src = assets.imageData;
          const rawHtml = marked.parse(assets.mdContent);
          const cleanHtml = DOMPurify.sanitize(rawHtml);
          document.getElementById('item-desc').innerHTML = cleanHtml;
        } else {
          alert('景品の取得に失敗しました');
        }
        
        const btn = document.getElementById('btn-pull');
        btn.disabled = false;
        btn.innerText = "もう一度回す";
        setGachaState('result_shown');
      }

      function onError(e) {
        alert(`エラーが発生しました: ${e}`);
        document.getElementById('btn-pull').disabled = false;
        setGachaState('error');
      }

      function showCredits() { /* Implementation skipped for brevity but ID exists */ }
      function closeCredits() { document.getElementById('credits-modal').classList.add('hidden'); }
    </script>
  </body>
</html>
